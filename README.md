# Лабораторная работа № 4 (Перегрузка операций)

## Задание

Класс: прямая.

Элементы класса: координаты двух точек `(x1,y1)` и `(x2,y2)`.

Методы: конструктор, деструктор, метод вывода уравнения прямой.

Перегружаемые операции: проверка параллельности двух прямых `||`, определение угла между двумя прямыми `%`.


## Описание пользовательского интерфейса программы

При запуске программа попросит пользователя ввести точки, которыми задаются прямые.
(Программа не работает с вырожденными точками, так как угол между такими прямыми не определён)

После того, как пользователь ввел данные, программа сделает все необходимые расчеты и продемонстрирует результат:
выведет уравнения этих прямых, сообщит об их параллельности / непараллельнрости, а также выведет угол между ними в радианах и градусах.



## Описание используемых алгоритмов и структур данных

Весь необходимый функционал описан в пользовательском классе `line`.
Также определена дружественная функция для печати уравнения в консоль.

### Сравнение дробных чисел

Числа типа `double` имеют погрешность, для учета которой введена константа `EPS`.

```cpp
const double EPS = 1e-7;
```

Для проверки равенства чисел типа `double` написана функция `eq`, которая проверяет нахождение одного числа в `EPS` окрестности другого.
Поскольку тело функции состоит всего из одной строки, функция объявлена как встраиваемая.

```cpp
inline double eq(double a, double b) { return a > b - EPS && a < b + EPS; }
```

### Приватные данные класса `line`

Координаты двух точек, которыми задается прямая, хранятся в переменных `x_1`, `x_2`, `y_1` и `y_2`.

Вычислением коэффициентов уравнения прямой занимается функция `init`. Если уравнение можно записать в виде `y = kx + b`, то 
значение `vertivcal` становится ложным и вычисляются коэффициенты `k` и `b`. Иначе `vertivcal` истинно и  вычисляется `c` для уравнения вида `x = c ( = const)`.

```cpp
void init() {
    if (x_1 == x_2) {
        vertical = true;
        c = x_1;
    }
    else {
        vertical = false;
        k = (double)(y_2 - y_1) / (x_2 - x_1);
        b = (double)(-x_1) * (y_2 - y_1) / (x_2 - x_1) + y_1;
    }
}
```

### Конструкторы

Конструктор по умолчанию инициализирует (списком инициализации) крайние точки какими-нибудь хорошими значениями (0 0 1 1) и запускает приватную функцию инициализации.
```cpp
line() : x_1(0), y_1(0), x_2(1), y_2(1) { init(); }
```

Второй констркуктор принимает аргументами координаты точек, которыми задается прямая и проводит инициализацию.
```cpp
line(int _x_1, int _y_1, int _x_2, int _y_2) : x_1(_x_1), y_1(_y_1), x_2(_x_2), y_2(_y_2) { init(); }
```

### Вывод уравнения прямой

Для вывода уравнения прямой в консоль используется перегрузка операции <<. Так как объект класса `line` является не правым операндом, а левым в привычной записи, то
функция перегрузки объявлена как дружественная в описании класса.

```cpp
friend ostream& operator << (ostream& os, line& t);
```

Сама функция описана вне класса `line`. 

```cpp
ostream& operator << (ostream& os, line& t) {
    if (t.vertical) {
        os << "x = " << t.c;
    }
    else {
        if (eq(t.k, 0)) {
            os << "y = " << t.b;
        }
        else {
            if (eq(t.b, 0))
                os << "y = " << t.k << " * x";
            else
                os << "y = " << t.k << " * x" << (t.b < 0 ? " - " : " + ") << abs(t.b);
        }
    }
    return os;
}
```

### Параллельность двух прямых

Для проверки парралельности используется функция перегрузки операции `||` (метод класса).
Прямые параллельны тогда и только тогда, когда равны соответствующие коэффициенты наклона (за исключением крайних случаев).

```cpp
bool operator || (const line& t) const {
    if (this->vertical && t.vertical)
        return true;
    else if (!this->vertical && !t.vertical)
        return this->k == t.k;
    else
        return false;
}
```

### Угол между прямыми

Используется перегрузка операции `%` (метод класса).
По точкам, задающим прямую строятся вектора. Из формулы скалрного произведения этих векторов можем найти косинус искомого угла, а значит и сам угол.

```cpp
double operator % (const line& t) const {
    double uv = (this->x_2 - this->x_1) * (t.x_2 - t.x_1) + (this->y_2 - this->y_1) * (t.y_2 - t.y_1);
    double u = sqrt((this->x_2 - this->x_1) * (this->x_2 - this->x_1) + (this->y_2 - this->y_1) * (this->y_2 - this->y_1));
    double v = sqrt((t.x_2 - t.x_1) * (t.x_2 - t.x_1) + (t.y_2 - t.y_1) * (t.y_2 - t.y_1));
    return acos(uv / (u * v));
}
```


## Пример работы программы

```
Прямая a
Первая точка:
x: 1
y: 4
Вторая точка:
x: -5
y: 0

Прямая b
Первая точка:
x: 0 
y: 0
Вторая точка:
x: 0
y: 10

Уравнение a: y = 0.667 * x + 3.333
Уравнение b: x = 0
Прямые не являются параллельными
Угол между прямыми: 2.159 = 123.690°
```


## Исходный код

(Находится в файле `main.cpp`)

```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;

const double EPS = 1e-7;
inline double eq(double a, double b) { return a > b - EPS && a < b + EPS; }

class line {
private:
    int x_1, x_2, y_1, y_2;

    bool vertical;
    double k, b;
    int c;

    void init() {
        if (x_1 == x_2) {
            vertical = true;
            c = x_1;
        }
        else {
            vertical = false;
            k = (double)(y_2 - y_1) / (x_2 - x_1);
            b = (double)(-x_1) * (y_2 - y_1) / (x_2 - x_1) + y_1;
        }
    }

public:
    line() : x_1(0), y_1(0), x_2(1), y_2(1) { init(); }
    line(int _x_1, int _y_1, int _x_2, int _y_2) : x_1(_x_1), y_1(_y_1), x_2(_x_2), y_2(_y_2) { init(); }

    friend ostream& operator << (ostream& os, line& t);

    bool operator || (const line& t) const {
        if (this->vertical && t.vertical)
            return true;
        else if (!this->vertical && !t.vertical)
            return this->k == t.k;
        else
            return false;
    }

    double operator % (const line& t) const {
        double uv = (this->x_2 - this->x_1) * (t.x_2 - t.x_1) + (this->y_2 - this->y_1) * (t.y_2 - t.y_1);
        double u = sqrt((this->x_2 - this->x_1) * (this->x_2 - this->x_1) + (this->y_2 - this->y_1) * (this->y_2 - this->y_1));
        double v = sqrt((t.x_2 - t.x_1) * (t.x_2 - t.x_1) + (t.y_2 - t.y_1) * (t.y_2 - t.y_1));
        return acos(uv / (u * v));
    }

    ~line() {}
};

ostream& operator << (ostream& os, line& t) {
    if (t.vertical) {
        os << "x = " << t.c;
    }
    else {
        if (eq(t.k, 0)) {
            os << "y = " << t.b;
        }
        else {
            if (eq(t.b, 0))
                os << "y = " << t.k << " * x";
            else
                os << "y = " << t.k << " * x" << (t.b < 0 ? " - " : " + ") << abs(t.b);
        }
    }
    return os;
}

int main() {

    cout << fixed << setprecision(3) << endl;

    int x_1, x_2, y_1, y_2;

    cout << "Прямая a\n";
    cout << "Первая точка:\n";
    cout << "x: "; cin >> x_1;
    cout << "y: "; cin >> y_1;
    cout << "Вторая точка:\n";
    cout << "x: "; cin >> x_2;
    cout << "y: "; cin >> y_2;

    line a(x_1, y_1, x_2, y_2);

    cout << endl;

    cout << "Прямая b\n";
    cout << "Первая точка:\n";
    cout << "x: "; cin >> x_1;
    cout << "y: "; cin >> y_1;
    cout << "Вторая точка:\n";
    cout << "x: "; cin >> x_2;
    cout << "y: "; cin >> y_2;

    line b(x_1, y_1, x_2, y_2);

    cout << endl;

    cout << "Уравнение a: " << a << endl;
    cout << "Уравнение b: " << b << endl;

    cout << (a || b ? "Прямые параллельны!" : "Прямые не являются параллельными") << endl;
    cout << "Угол между прямыми: " << (a % b) << " = " << (a % b) / acos(-1) * 180 << "°" << endl;

    return 0;
}
```
